#pragma once

#include "RingBuffer.h"
#include "endian.h"

#include "AppleMidi_Namespace.h"

BEGIN_APPLEMIDI_NAMESPACE

#include "AppleMidi_Defs.h"

template<class UdpClass>
class AppleMidiTransport;

template<class UdpClass>
class AppleMIDIParser
{
public:
	static size_t Parser(RingBuffer<byte, BUFFER_MAX_SIZE>& buffer, AppleMidiTransport<UdpClass>* session, const amPortType& portType)
	{
		byte a[8]; 

		// N_DEBUG_PRINT("AppleMIDI_Parser::Parser received ");
		// N_DEBUG_PRINT(buffer.getLength());
		// N_DEBUG_PRINTLN(" bytes");

		size_t minimumLen = (2 + 2); // Signature + Command
		if (buffer.getLength() < minimumLen) {
			// N_DEBUG_PRINT("PARSER_NOT_ENOUGH_DATA ");
			return PARSER_NOT_ENOUGH_DATA;
		}

		size_t i = 0;

		byte signature[2]; // Signature "Magic Value" for Apple network MIDI session establishment 
		signature[0] = buffer.peek(i++);
		signature[1] = buffer.peek(i++);
		if (0 != memcmp(signature, amSignature, sizeof(amSignature))) {
			// N_DEBUG_PRINT("Wrong signature: 0x");
			// N_DEBUG_PRINT(signature[0], HEX);
			// N_DEBUG_PRINT(signature[1], HEX);
			// N_DEBUG_PRINTLN(" was expecting 0xFFFF");

			return PARSER_UNEXPECTED_DATA;
		}

		byte command[2]; // 16-bit command identifier (two ASCII characters, first in high 8 bits, second in low 8 bits)
		command[0] = buffer.peek(i++);
		command[1] = buffer.peek(i++);

		if (false)
		{
		}
#ifdef APPLEMIDI_LISTENER
		else if (0 == memcmp(command, amInvitation, sizeof(amInvitation)))
		{
			//N_DEBUG_PRINTLN("received Invitation");

			// minimum amount : 4 bytes for protocol version, 4 bytes for APPLEMIDI_INITIATOR token, 4 bytes for sender SSRC
			minimumLen += (4 + 4 + 4);
			if (buffer.getLength() < minimumLen) {
				//N_DEBUG_PRINT("PARSER_NOT_ENOUGH_DATA ");
				return PARSER_NOT_ENOUGH_DATA;
			}

			// 2 (stored in network byte order (big-endian))
			byte protocolVersion[4];
			protocolVersion[0] = buffer.peek(i++);
			protocolVersion[1] = buffer.peek(i++);
			protocolVersion[2] = buffer.peek(i++);
			protocolVersion[3] = buffer.peek(i++);
			if (0 != memcmp(protocolVersion, amProtocolVersion, sizeof(amProtocolVersion))) {
				// N_DEBUG_PRINT("Wrong protocolVersion: 0x");
				// N_DEBUG_PRINT(protocolVersion[0], HEX);
				// N_DEBUG_PRINT(protocolVersion[1], HEX);
				// N_DEBUG_PRINT(protocolVersion[2], HEX);
				// N_DEBUG_PRINT(protocolVersion[3], HEX);
				// N_DEBUG_PRINTLN(" was expecting 0x00000002");
				return PARSER_UNEXPECTED_DATA;
			}
			
			AppleMIDI_Invitation invitation;

			// A random number generated by the session's APPLEMIDI_INITIATOR.
			a[0] = buffer.peek(i++); a[1] = buffer.peek(i++); a[2] = buffer.peek(i++); a[3] = buffer.peek(i++); 
			invitation.initiatorToken = ntohl(a[0], a[1], a[2], a[3]);
			// The sender's synchronization source identifier.
			a[0] = buffer.peek(i++); a[1] = buffer.peek(i++); a[2] = buffer.peek(i++); a[3] = buffer.peek(i++); 
			invitation.ssrc = ntohl(a[0], a[1], a[2], a[3]);

			// N_DEBUG_PRINT("initiator: 0x");
			// N_DEBUG_PRINTLN(invitation.initiatorToken, HEX);
			// N_DEBUG_PRINT("senderSSRC: 0x");
			// N_DEBUG_PRINTLN(invitation.ssrc, HEX);

			uint16_t bi = 0;
			while ((i < buffer.getLength()) && (buffer.peek(i) != 0x00) && (bi <= APPLEMIDI_SESSION_NAME_MAX_LEN))
				invitation.sessionName[bi++] = buffer.peek(i++);
			invitation.sessionName[bi++] = '\0';

			if (i == buffer.getLength() || buffer.peek(i++) != 0x00)
			{
				//N_DEBUG_PRINTLN("PARSER_NOT_ENOUGH_DATA");
				return PARSER_NOT_ENOUGH_DATA;
			}

			// N_DEBUG_PRINT("Consumed ");
			// N_DEBUG_PRINT(i);
			// N_DEBUG_PRINTLN(" bytes");

			buffer.pop(i); // consume all the bytes that made up this message

			// N_DEBUG_PRINT("Remaining bytes ");
			// N_DEBUG_PRINT(buffer.getLength());
			// N_DEBUG_PRINTLN(" bytes");

			session->ReceivedInvitation(invitation, portType);

			return i;
		}
		else if (0 == memcmp(command, amEndSession, sizeof(amEndSession)))
		{
			//N_DEBUG_PRINTLN("received EndSession");

			// minimum amount : 4 bytes for protocol version, 4 bytes for APPLEMIDI_INITIATOR token, 4 bytes for sender SSRC
			minimumLen += (4 + 4 + 4);
			if (buffer.getLength() < minimumLen) 
				return PARSER_NOT_ENOUGH_DATA;

			// 2 (stored in network byte order (big-endian))
			byte protocolVersion[4];
			protocolVersion[0] = buffer.peek(i++);
			protocolVersion[1] = buffer.peek(i++);
			protocolVersion[2] = buffer.peek(i++);
			protocolVersion[3] = buffer.peek(i++);
			if (0 != memcmp(protocolVersion, amProtocolVersion, sizeof(amProtocolVersion))) {
				// N_DEBUG_PRINT("Wrong protocolVersion: 0x");
				// N_DEBUG_PRINT(protocolVersion[0], HEX);
				// N_DEBUG_PRINT(protocolVersion[1], HEX);
				// N_DEBUG_PRINT(protocolVersion[2], HEX);
				// N_DEBUG_PRINT(protocolVersion[3], HEX);
				// N_DEBUG_PRINTLN(" was expecting 0x00000002");
				return PARSER_UNEXPECTED_DATA;
			}

			AppleMIDI_EndSession endSession;

			// A random number generated by the session's APPLEMIDI_INITIATOR.
			a[0] = buffer.peek(i++); a[1] = buffer.peek(i++); a[2] = buffer.peek(i++); a[3] = buffer.peek(i++); 
			endSession.initiatorToken = ntohl(a[0], a[1], a[2], a[3]);
			// The sender's synchronization source identifier.
			a[0] = buffer.peek(i++); a[1] = buffer.peek(i++); a[2] = buffer.peek(i++); a[3] = buffer.peek(i++); 
			endSession.ssrc = ntohl(a[0], a[1], a[2], a[3]);

			// N_DEBUG_PRINT("Consumed ");
			// N_DEBUG_PRINT(i);
			// N_DEBUG_PRINTLN(" bytes");

			buffer.pop(i); // consume all the bytes that made up this message

			session->ReceivedEndSession(endSession);

			return i;
		}
		else if (0 == memcmp(command, amSynchronization, sizeof(amSynchronization)))
		{
			//N_DEBUG_PRINTLN("received Syncronization");

			// minimum amount : 4 bytes for sender SSRC, 1 byte for count, 3 bytes padding and 3 times 8 bytes
			minimumLen += (4 + 1 + 3 + (3 * 8));
			if (buffer.getLength() < minimumLen) 
				return PARSER_NOT_ENOUGH_DATA;

			AppleMIDI_Synchronization synchronization;

			// The sender's synchronization source identifier.
			a[0] = buffer.peek(i++); a[1] = buffer.peek(i++); a[2] = buffer.peek(i++); a[3] = buffer.peek(i++); 
			synchronization.ssrc = ntohl(a[0], a[1], a[2], a[3]);
			synchronization.count = buffer.peek(i++);
			buffer.peek(i++); buffer.peek(i++); buffer.peek(i++); // padding, unused
			a[0] = buffer.peek(i++); a[1] = buffer.peek(i++); a[2] = buffer.peek(i++); a[3] = buffer.peek(i++); a[4] = buffer.peek(i++); a[5] = buffer.peek(i++); a[6] = buffer.peek(i++); a[7] = buffer.peek(i++); 
			synchronization.timestamps[0] = ntohll(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
			a[0] = buffer.peek(i++); a[1] = buffer.peek(i++); a[2] = buffer.peek(i++); a[3] = buffer.peek(i++); a[4] = buffer.peek(i++); a[5] = buffer.peek(i++); a[6] = buffer.peek(i++); a[7] = buffer.peek(i++); 
			synchronization.timestamps[1] = ntohll(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
			a[0] = buffer.peek(i++); a[1] = buffer.peek(i++); a[2] = buffer.peek(i++); a[3] = buffer.peek(i++); a[4] = buffer.peek(i++); a[5] = buffer.peek(i++); a[6] = buffer.peek(i++); a[7] = buffer.peek(i++); 
			synchronization.timestamps[2] = ntohll(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]);

			// N_DEBUG_PRINT("Consumed ");
			// N_DEBUG_PRINT(i);
			// N_DEBUG_PRINTLN(" bytes");

			buffer.pop(i); // consume all the bytes that made up this message

			session->ReceivedSynchronization(synchronization);

			return i;
		}
		else if (0 == memcmp(command, amReceiverFeedback, sizeof(amReceiverFeedback)))
		{
			// N_DEBUG_PRINTLN("received ReceiverFeedback");

			// minimum amount : 4 bytes for sender SSRC, 4 bytes for sequence number
			minimumLen += (4 + 4);
			if (buffer.getLength() < minimumLen) 
				return PARSER_NOT_ENOUGH_DATA;

			a[0] = buffer.peek(i++); a[1] = buffer.peek(i++); a[2] = buffer.peek(i++); a[3] = buffer.peek(i++); 
			ssrc_t ssrc = ntohl(a[0], a[1], a[2], a[3]);

			a[0] = buffer.peek(i++); a[1] = buffer.peek(i++); a[2] = buffer.peek(i++); a[3] = buffer.peek(i++); 
			uint16_t sequenceNr = ntohs(a[0], a[1]);

			// N_DEBUG_PRINT("ssrc: 0x");
			// N_DEBUG_PRINTLN(ssrc, HEX);
			// N_DEBUG_PRINT("sequenceNr: ");
			// N_DEBUG_PRINTLN(sequenceNr);

			buffer.pop(i); // consume all the bytes that made up this message

			// N_DEBUG_PRINT("Consumed ");
			// N_DEBUG_PRINT(i);
			// N_DEBUG_PRINTLN(" bytes");

			return i;
		}
#endif
#ifdef APPLEMIDI_INITIATOR
		else if (0 == memcmp(command, amBitrateReceiveLimit, sizeof(amBitrateReceiveLimit)))
		{
			return 99;
		}
		else if (0 == memcmp(command, amInvitationAccepted, sizeof(amInvitationAccepted)))
		{
		return 99;
		}
		else if (0 == memcmp(command, amInvitationRejected, sizeof(amInvitationRejected)))
		{
		return 99;
		}
#endif
		return PARSER_UNEXPECTED_DATA;
	}
};

END_APPLEMIDI_NAMESPACE