#pragma once

#include "RingBuffer.h"
#include "endian.h"

#include "AppleMidi_Defs.h"
#include "AppleMidi_Settings.h"

#include "AppleMidi_Namespace.h"

BEGIN_APPLEMIDI_NAMESPACE

#ifndef PARSER_NOT_ENOUGH_DATA
#define PARSER_NOT_ENOUGH_DATA 0
#endif

#ifndef PARSER_UNEXPECTED_DATA
#define PARSER_UNEXPECTED_DATA -1
#endif

template <class UdpClass, class Settings>
class AppleMidiTransport;

template <class UdpClass, class Settings>
class AppleMIDIParser
{
public:
	AppleMidiTransport<UdpClass, Settings> *session;

	size_t parse(RingBuffer<byte, Settings::MaxBufferSize> &buffer, const amPortType &portType)
	{
		conversionBuffer cb;

		T_DEBUG_PRINT("AppleMIDI_Parser::Parser received ");
		T_DEBUG_PRINT(buffer.getLength());
		T_DEBUG_PRINTLN(" bytes");

		byte signature[2]; // Signature "Magic Value" for Apple network MIDI session establishment
		byte command[2];   // 16-bit command identifier (two ASCII characters, first in high 8 bits, second in low 8 bits)

		size_t minimumLen = (sizeof(signature) + sizeof(command)); // Signature + Command
		if (buffer.getLength() < minimumLen)
		{
			W_DEBUG_PRINT("PARSER_NOT_ENOUGH_DATA ");
			return PARSER_NOT_ENOUGH_DATA;
		}

		size_t i = 0; // TODO: rename to consumed

		signature[0] = buffer.peek(i++);
		signature[1] = buffer.peek(i++);
		if (0 != memcmp(signature, amSignature, sizeof(amSignature)))
		{
			// E_DEBUG_PRINT("Wrong signature: 0x");
			// E_DEBUG_PRINT(signature[0], HEX);
			// E_DEBUG_PRINT(signature[1], HEX);
			// E_DEBUG_PRINTLN(" was expecting 0xFFFF");

			return PARSER_UNEXPECTED_DATA;
		}

		command[0] = buffer.peek(i++);
		command[1] = buffer.peek(i++);

		if (false)
		{
		}
#ifdef APPLEMIDI_LISTENER
		else if (0 == memcmp(command, amInvitation, sizeof(amInvitation)))
		{
			N_DEBUG_PRINTLN("received Invitation");

			byte protocolVersion[4];

			minimumLen += (sizeof(protocolVersion) + sizeof(initiatorToken_t) + sizeof(ssrc_t));
			if (buffer.getLength() < minimumLen)
			{
				//N_DEBUG_PRINT("PARSER_NOT_ENOUGH_DATA ");
				return PARSER_NOT_ENOUGH_DATA;
			}

			// 2 (stored in network byte order (big-endian))
			protocolVersion[0] = buffer.peek(i++);
			protocolVersion[1] = buffer.peek(i++);
			protocolVersion[2] = buffer.peek(i++);
			protocolVersion[3] = buffer.peek(i++);
			if (0 != memcmp(protocolVersion, amProtocolVersion, sizeof(amProtocolVersion)))
			{
				// N_DEBUG_PRINT("Wrong protocolVersion: 0x");
				// N_DEBUG_PRINT(protocolVersion[0], HEX);
				// N_DEBUG_PRINT(protocolVersion[1], HEX);
				// N_DEBUG_PRINT(protocolVersion[2], HEX);
				// N_DEBUG_PRINT(protocolVersion[3], HEX);
				// N_DEBUG_PRINTLN(" was expecting 0x00000002");
				return PARSER_UNEXPECTED_DATA;
			}

			AppleMIDI_Invitation invitation;

			// A random number generated by the session's APPLEMIDI_INITIATOR.
			cb.buffer[0] = buffer.peek(i++);
			cb.buffer[1] = buffer.peek(i++);
			cb.buffer[2] = buffer.peek(i++);
			cb.buffer[3] = buffer.peek(i++);
			invitation.initiatorToken = ntohl(cb.value32);
			
			// The sender's synchronization source identifier.
			cb.buffer[0] = buffer.peek(i++);
			cb.buffer[1] = buffer.peek(i++);
			cb.buffer[2] = buffer.peek(i++);
			cb.buffer[3] = buffer.peek(i++);
			invitation.ssrc = ntohl(cb.value32);

			V_DEBUG_PRINT("initiator: 0x");
			V_DEBUG_PRINTLN(invitation.initiatorToken, HEX);
			V_DEBUG_PRINT("senderSSRC: 0x");
			V_DEBUG_PRINTLN(invitation.ssrc, HEX);

			uint16_t bi = 0;
			while ((i < buffer.getLength()) && (buffer.peek(i) != 0x00) && (bi <= APPLEMIDI_SESSION_NAME_MAX_LEN))
				invitation.sessionName[bi++] = buffer.peek(i++);
			invitation.sessionName[bi++] = '\0';

			if (i == buffer.getLength() || buffer.peek(i++) != 0x00)
			{
				//N_DEBUG_PRINTLN("PARSER_NOT_ENOUGH_DATA");
				return PARSER_NOT_ENOUGH_DATA;
			}

			V_DEBUG_PRINT("Consumed ");
			V_DEBUG_PRINT(i);
			V_DEBUG_PRINTLN(" bytes");

			buffer.pop(i); // consume all the bytes that made up this message

			V_DEBUG_PRINT("Remaining bytes ");
			V_DEBUG_PRINT(buffer.getLength());
			V_DEBUG_PRINTLN(" bytes");

			session->ReceivedInvitation(invitation, portType);

			return i;
		}
		else if (0 == memcmp(command, amEndSession, sizeof(amEndSession)))
		{
			N_DEBUG_PRINTLN("received EndSession");

			byte protocolVersion[4];

			minimumLen += (sizeof(protocolVersion) + sizeof(initiatorToken_t) + sizeof(ssrc_t));
			if (buffer.getLength() < minimumLen)
				return PARSER_NOT_ENOUGH_DATA;

			// 2 (stored in network byte order (big-endian))
			protocolVersion[0] = buffer.peek(i++);
			protocolVersion[1] = buffer.peek(i++);
			protocolVersion[2] = buffer.peek(i++);
			protocolVersion[3] = buffer.peek(i++);
			if (0 != memcmp(protocolVersion, amProtocolVersion, sizeof(amProtocolVersion)))
			{
				// N_DEBUG_PRINT("Wrong protocolVersion: 0x");
				// N_DEBUG_PRINT(protocolVersion[0], HEX);
				// N_DEBUG_PRINT(protocolVersion[1], HEX);
				// N_DEBUG_PRINT(protocolVersion[2], HEX);
				// N_DEBUG_PRINT(protocolVersion[3], HEX);
				// N_DEBUG_PRINTLN(" was expecting 0x00000002");
				return PARSER_UNEXPECTED_DATA;
			}

			AppleMIDI_EndSession endSession;

			// A random number generated by the session's APPLEMIDI_INITIATOR.
			cb.buffer[0] = buffer.peek(i++);
			cb.buffer[1] = buffer.peek(i++);
			cb.buffer[2] = buffer.peek(i++);
			cb.buffer[3] = buffer.peek(i++);
			endSession.initiatorToken = ntohl(cb.value32);
			// The sender's synchronization source identifier.
			cb.buffer[0] = buffer.peek(i++);
			cb.buffer[1] = buffer.peek(i++);
			cb.buffer[2] = buffer.peek(i++);
			cb.buffer[3] = buffer.peek(i++);
			endSession.ssrc = ntohl(cb.value32);

			V_DEBUG_PRINT("Consumed ");
			V_DEBUG_PRINT(i);
			V_DEBUG_PRINTLN(" bytes");

			buffer.pop(i); // consume all the bytes that made up this message

			session->ReceivedEndSession(endSession);

			return i;
		}
		else if (0 == memcmp(command, amSynchronization, sizeof(amSynchronization)))
		{
			N_DEBUG_PRINTLN("received Syncronization");

			AppleMIDI_Synchronization synchronization;

			// minimum amount : 4 bytes for sender SSRC, 1 byte for count, 3 bytes padding and 3 times 8 bytes
			minimumLen += (4 + 1 + 3 + (3 * 8));
			if (buffer.getLength() < minimumLen)
				return PARSER_NOT_ENOUGH_DATA;

			// The sender's synchronization source identifier.
			cb.buffer[0] = buffer.peek(i++);
			cb.buffer[1] = buffer.peek(i++);
			cb.buffer[2] = buffer.peek(i++);
			cb.buffer[3] = buffer.peek(i++);
			synchronization.ssrc = ntohl(cb.value32);

			synchronization.count = buffer.peek(i++);
			buffer.peek(i++);
			buffer.peek(i++);
			buffer.peek(i++); // padding, unused
			cb.buffer[0] = buffer.peek(i++);
			cb.buffer[1] = buffer.peek(i++);
			cb.buffer[2] = buffer.peek(i++);
			cb.buffer[3] = buffer.peek(i++);
			cb.buffer[4] = buffer.peek(i++);
			cb.buffer[5] = buffer.peek(i++);
			cb.buffer[6] = buffer.peek(i++);
			cb.buffer[7] = buffer.peek(i++);
			synchronization.timestamps[0] = ntohll(cb.value64);

			cb.buffer[0] = buffer.peek(i++);
			cb.buffer[1] = buffer.peek(i++);
			cb.buffer[2] = buffer.peek(i++);
			cb.buffer[3] = buffer.peek(i++);
			cb.buffer[4] = buffer.peek(i++);
			cb.buffer[5] = buffer.peek(i++);
			cb.buffer[6] = buffer.peek(i++);
			cb.buffer[7] = buffer.peek(i++);
			synchronization.timestamps[1] = ntohll(cb.value64);

			cb.buffer[0] = buffer.peek(i++);
			cb.buffer[1] = buffer.peek(i++);
			cb.buffer[2] = buffer.peek(i++);
			cb.buffer[3] = buffer.peek(i++);
			cb.buffer[4] = buffer.peek(i++);
			cb.buffer[5] = buffer.peek(i++);
			cb.buffer[6] = buffer.peek(i++);
			cb.buffer[7] = buffer.peek(i++);
			synchronization.timestamps[2] = ntohll(cb.value64);

			V_DEBUG_PRINT("Consumed ");
			V_DEBUG_PRINT(i);
			V_DEBUG_PRINTLN(" bytes");

			buffer.pop(i); // consume all the bytes that made up this message

			session->ReceivedSynchronization(synchronization);

			return i;
		}
		else if (0 == memcmp(command, amReceiverFeedback, sizeof(amReceiverFeedback)))
		{
			//N_DEBUG_PRINTLN("received ReceiverFeedback");

			AppleMIDI_ReceiverFeedback receiverFeedback;

			minimumLen += (sizeof(receiverFeedback.ssrc) + sizeof(receiverFeedback.sequenceNr) + sizeof(receiverFeedback.dummy));
			if (buffer.getLength() < minimumLen)
				return PARSER_NOT_ENOUGH_DATA;

			cb.buffer[0] = buffer.peek(i++);
			cb.buffer[1] = buffer.peek(i++);
			cb.buffer[2] = buffer.peek(i++);
			cb.buffer[3] = buffer.peek(i++);
			receiverFeedback.ssrc = ntohl(cb.value32);

			cb.buffer[0] = buffer.peek(i++);
			cb.buffer[1] = buffer.peek(i++);
			receiverFeedback.sequenceNr = ntohs(cb.value16);
			cb.buffer[0] = buffer.peek(i++);
			cb.buffer[1] = buffer.peek(i++);
			receiverFeedback.dummy = ntohs(cb.value16);

			V_DEBUG_PRINT("ssrc: 0x");
			V_DEBUG_PRINTLN(ssrc, HEX);
			V_DEBUG_PRINT("sequenceNr: ");
			V_DEBUG_PRINTLN(sequenceNr);

			buffer.pop(i); // consume all the bytes that made up this message

			session->ReceivedReceiverFeedback(receiverFeedback);

			V_DEBUG_PRINT("Consumed ");
			V_DEBUG_PRINT(i);
			V_DEBUG_PRINTLN(" bytes");

			return i;
		}
#endif
#ifdef APPLEMIDI_INITIATOR
		else if (0 == memcmp(command, amBitrateReceiveLimit, sizeof(amBitrateReceiveLimit)))
		{
			return 99;
		}
		else if (0 == memcmp(command, amInvitationAccepted, sizeof(amInvitationAccepted)))
		{
			return 99;
		}
		else if (0 == memcmp(command, amInvitationRejected, sizeof(amInvitationRejected)))
		{
			return 99;
		}
#endif
		return PARSER_UNEXPECTED_DATA;
	}
};

END_APPLEMIDI_NAMESPACE