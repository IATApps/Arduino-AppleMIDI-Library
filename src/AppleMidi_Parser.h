BEGIN_APPLEMIDI_NAMESPACE

#include <midi_RingBuffer.h>
using namespace MIDI_NAMESPACE;

#include "AppleMidi_Settings.h"
#include "AppleMidi_Util.h"

template<class UdpClass>
class AppleMidiTransport;

template<class UdpClass>
class AppleMIDIParser
{
public:
	static int Parser(midi::RingBuffer<byte, BUFFER_MAX_SIZE>& buffer, AppleMidiTransport<UdpClass>* appleMidi, const amPortType& portType)
	{
		Serial.print("AppleMIDI_Parser::Parser received ");
		Serial.print(buffer.getLength());
		Serial.println(" bytes");

		uint16_t minimumLen = 4;
		if (buffer.getLength() < minimumLen) return 0;

		uint16_t i = 0;

		byte signature[2]; // Signature "Magic Value" for Apple network MIDI session establishment 
		signature[0] = buffer.peek(i++);
		signature[1] = buffer.peek(i++);
		if (0 != memcmp(signature, amSignature, sizeof(amSignature)))
		{
			Serial.print("Wrong signature: 0x");
			Serial.print(signature[0], HEX);
			Serial.print(signature[1], HEX);
			Serial.println(" was expecting 0xFFFF");

			return i; // these bytes can be consumed
		}

		byte command[2]; // 16-bit command identifier (two ASCII characters, first in high 8 bits, second in low 8 bits)
		command[0] = buffer.peek(i++);
		command[1] = buffer.peek(i++);
		if (0 == memcmp(command, amInvitation, sizeof(amInvitation)))
		{
			// minimum amount : 4 bytes for protocol version, 4 bytes for initiator token, 4 bytes for sender SSRC
			minimumLen += (4 + 4 + 4);
			if (buffer.getLength() < minimumLen) return 0;

			// 2 (stored in network byte order (big-endian))
			uint32_t protocolVersion = readUInt32(buffer.peek(i++), buffer.peek(i++), buffer.peek(i++), buffer.peek(i++));
			if (protocolVersion != amProtocolVersion)
			{
				Serial.print("Wrong protocolVersion: ");
				Serial.print(protocolVersion);
				Serial.println(" was expecting 2");

				return i;
			}

			AppleMIDI_Invitation_t invitation;

			// A random number generated by the session’s initiator.
			invitation.initiatorToken = readUInt32(buffer.peek(i++), buffer.peek(i++), buffer.peek(i++), buffer.peek(i++));
			// The sender's synchronization source identifier.
			invitation.ssrc = readUInt32(buffer.peek(i++), buffer.peek(i++), buffer.peek(i++), buffer.peek(i++));

			//Serial.print("protocolVersion: ");
			//Serial.println(protocolVersion);
			//Serial.print("initiatorToken: 0x");
			//Serial.println(invitation.initiatorToken, HEX);
			//Serial.print("senderSSRC: 0x");
			//Serial.println(invitation.ssrc, HEX);

			char s = buffer.peek(i++);
			invitation.sessionName[0] = '\0';
			//Serial.print(s);
			uint16_t bi = 0;
			while (i < buffer.getLength() && s != 0x00 && bi <= SESSION_NAME_MAX_LEN)
			{
				invitation.sessionName[bi++] = s;
				s = buffer.peek(i++);
				//Serial.print(s);
			}
			//Serial.println();
			invitation.sessionName[bi++] = '\0';

			if (s != 0x00)
			{
				Serial.println("Could not find 0x00, not enough data");
				return 0;
			}

			//Serial.print("Consumed ");
			//Serial.print(i);
			//Serial.println(" bytes");

			buffer.pop(i); // consume all the bytes that made up this message

			appleMidi->ReceivedInvitation(invitation, portType);

			return i;
		}
		else if (0 == memcmp(command, amInvitationAccepted, sizeof(amInvitationAccepted)))
		{
			return 99;
		}
		else if (0 == memcmp(command, amInvitationRejected, sizeof(amInvitationRejected)))
		{
			return 99;
		}
		else if (0 == memcmp(command, amEndSession, sizeof(amEndSession)))
		{
			return 99;
		}
		else if (0 == memcmp(command, amSyncronization, sizeof(amSyncronization)))
		{
			return 99;
		}
		else if (0 == memcmp(command, amReceiverFeedback, sizeof(amReceiverFeedback)))
		{
			return 99;
		}
		else if (0 == memcmp(command, amBitrateReceiveLimit, sizeof(amBitrateReceiveLimit)))
		{
			return 99;
		}

		return 0;
	}
};

END_APPLEMIDI_NAMESPACE